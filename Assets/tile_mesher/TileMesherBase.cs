using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

namespace MeshBuilder
{
    abstract public class TileMesherBase<TileVariant> : IMeshBuilder where TileVariant : struct
    {
        private static readonly Mesh NullMesh = new Mesh();

        protected enum State { Uninitialized, Initialized, Generating }

        protected enum GenerationType
        {
            /// <summary>
            /// Generate the data for the tiles and dispose of it after the mesh is ready, 
            /// the current meshers don't generate considerable amount of data in most cases 
            /// but if the mesh is static, there is no need to keep it in memory, 
            /// it may be also useful if there is a lot of chunks
            /// </summary>
            FromDataUncached,

            /// <summary>
            /// Generate the data for the tiles and keep it in memory, it's less work, and if there is
            /// randomness in the tile variants they don't change with every regeneration of the mesh
            /// </summary>
            FromDataCachedTiles,

            /// <summary>
            /// The tiles aren't generated by the mesher, it is loaded from somewhere else
            /// </summary>
            FromTiles
        }

        public string Name { get; private set; }
        protected State state = State.Uninitialized;
        protected GenerationType generationType = GenerationType.FromDataUncached;

        private TileThemePalette themePalette;
        public TileThemePalette ThemePalette
        {
            get
            {
                return themePalette;
            }
            protected set
            {
                if (themePalette != null)
                {
                    themePalette.EndUse();
                }
                themePalette = value;
                if (themePalette != null)
                {
                    themePalette.BeginUse();
                }
            }
        }

        // GENERATED DATA
        protected Volume<TileVariant> tiles;
        protected JobHandle lastHandle;

        public Mesh Mesh { get; protected set; }

        public TileMesherBase(string name)
        {
            Name = name;

            Mesh = new Mesh();
            Mesh.name = name;
        }

        public void StartGeneration()
        {
            if (!IsInitialized)
            {
                Error("not initialized!");
                return;
            }

            if (IsGenerating)
            {
                Error("is already generating!");
                return;
            }

            state = State.Generating;

            lastHandle.Complete();
            DisposeTemp();

            ScheduleGenerationJobs();
        }

        abstract protected void ScheduleGenerationJobs();

        public void EndGeneration()
        {
            if (!IsGenerating)
            {
                Warning("is not generating! nothing to stop");
                return;
            }

            lastHandle.Complete();
            state = State.Initialized;

            AfterGenerationJobsComplete();

            if (generationType == GenerationType.FromDataUncached)
            {
                if (HasTilesData)
                {
                    tiles.Dispose();
                    tiles = null;
                }
            }

            DisposeTemp();
        }

        abstract protected void AfterGenerationJobsComplete();

        virtual public void Dispose()
        {
            state = State.Uninitialized;

            lastHandle.Complete();
            DisposeTemp();

            if (tiles != null)
            {
                tiles.Dispose();
                tiles = null;
            }

            ThemePalette = null;
        }

        virtual protected void DisposeTemp()
        {

        }

        /// <summary>
        /// Combines the mesh instance array int a single mesh, using the base pieces from the theme.
        /// </summary>
        /// <param name="mesh">The result will be generated into this</param>
        /// <param name="instanceData">Input data. NOTE: the MeshInstance structs have to be initialized, except for the mesh field of the CombineInstance struct, this will be set from the theme.</param>
        /// <param name="theme">Theme which provides the base mesh pieces.</param>
        static protected void CombineMeshes(Mesh mesh, NativeArray<MeshInstance> instanceData, TileTheme theme)
        {
            var basePieces = theme.BaseVariants;
            var instanceArray = new CombineInstance[instanceData.Length];
            for (int i = 0; i < instanceData.Length; ++i)
            {
                var data = instanceData[i];

                if (data.basePieceIndex >= 0)
                {
                    var variants = basePieces[data.basePieceIndex].Variants;
                    data.instance.mesh = variants[data.variantIndex];
                    instanceArray[i] = data.instance;
                }
                else
                {
                    instanceArray[i].mesh = NullMesh;
                }
            }

            mesh.CombineMeshes(instanceArray, true, true);
        }

        protected void Warning(string msg, params object[] args)
        {
            Debug.LogWarningFormat(Name + " - " + msg, args);
        }

        protected void Error(string msg, params object[] args)
        {
            Debug.LogErrorFormat(Name + " - " + msg, args);
        }

        public bool IsInitialized { get { return state != State.Uninitialized; } }
        public bool IsGenerating { get { return state == State.Generating; } }

        protected bool HasTilesData { get { return tiles != null && !tiles.IsDisposed; } }

        /// <summary>
        /// Contains data for rendering a mesh piece. The matrix and indices are usually 
        /// set earlier from a job, then later the indices are used to set the mesh.
        /// (Since the mesh objects can't be handled inside the jobs.)
        /// These MeshInstance struct will be combined into the final mesh.
        /// </summary>
        protected struct MeshInstance
        {
            public CombineInstance instance;
            public int basePieceIndex;
            public byte variantIndex;
        }
    }
}
